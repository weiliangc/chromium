<!DOCTYPE html>
<meta charset="utf-8">
<title>NavigationPreloadManager.getState</title>
<script src="../../resources/testharness.js"></script>
<script src="../../resources/testharnessreport.js"></script>
<script src="../resources/test-helpers.js"></script>
<body>
<script>
function post_and_wait_for_reply(worker, message) {
  return new Promise(resolve => {
      navigator.serviceWorker.onmessage = e => { resolve(e.data); };
      worker.postMessage(message);
    });
}

promise_test(t => {
  const scope = '../resources/getState';
  const script = '../resources/empty-worker.js';
  var registration;

  return service_worker_unregister_and_register(t, script, scope)
    .then(r => {
        registration = r;
        add_completion_callback(() => registration.unregister());
        return registration.navigationPreload.getState();
      })
    .then(state => {
        assert_equals(state.enabled, false,
                      '.enabled should be false by default');
        return registration.navigationPreload.enable();
      })
    .then(() => registration.navigationPreload.getState())
    .then(state => {
        assert_equals(state.enabled, true,
                      '.enabled should be true after enable()');
        return registration.navigationPreload.disable();
      })
    .then(() => registration.navigationPreload.getState())
    .then(state => {
        assert_equals(state.enabled, false,
                      '.enabled should be false after disable()');
      });
  }, 'getState');

// This test sends commands to a worker to call enable()/disable()/getState().
// It checks the results from the worker and verifies that they match the
// navigation preload state accessible from the page.
promise_test(t => {
  const scope = 'resources/getState-worker';
  const script = 'resources/get-state-worker.js';
  var worker;
  var registration;

  return service_worker_unregister_and_register(t, script, scope)
    .then(r => {
        registration = r;
        add_completion_callback(() => registration.unregister());
        worker = registration.installing;
        // Call getState().
        return post_and_wait_for_reply(worker, 'getState');
      })
    .then(data => {
        return Promise.all([data, registration.navigationPreload.getState()]);
      })
    .then(states => {
        assert_equals(states[0].enabled, false,
                      '.enabled should be false by default (from worker)');
        assert_equals(states[1].enabled, false,
                      '.enabled should be false by default (from page)');
        // Call enable() and then getState().
        return post_and_wait_for_reply(worker, 'enable');
      })
    .then(data => {
        assert_equals(data, undefined, 'enable() should resolve to undefined');
        return Promise.all([
            post_and_wait_for_reply(worker, 'getState'),
            registration.navigationPreload.getState()
          ]);
      })
    .then(states => {
        assert_equals(states[0].enabled, true,
                      '.enabled should be true after enable() (from worker)');
        assert_equals(states[1].enabled, true,
                      '.enabled should be true after enable() (from page)');
        // Call disable() and then getState().
        return post_and_wait_for_reply(worker, 'disable');
      })
    .then(data => {
        assert_equals(data, undefined,
                      '.disable() should resolve to undefined');
        return Promise.all([
            post_and_wait_for_reply(worker, 'getState'),
            registration.navigationPreload.getState()
          ]);
      })
    .then(states => {
        assert_equals(states[0].enabled, false,
                      '.enabled should be false after disable() (from worker)');
        assert_equals(states[1].enabled, false,
                      '.enabled should be false after disable() (from page)');
      });
  }, 'getState from a worker');
</script>
</body>

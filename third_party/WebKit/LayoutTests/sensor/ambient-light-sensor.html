<!DOCTYPE html>
<script src="../resources/testharness.js"></script>
<script src="../resources/testharnessreport.js"></script>
<script src="../resources/mojo-helpers.js"></script>
<script src="resources/sensor-helpers.js"></script>
<script>

'use strict';

if (!window.testRunner)
    debug('This test cannot be run without the TestRunner');

const kDefaultReadingValue = 3.1415;

function update_sensor_reading(buffer) {
  buffer[1] = window.performance.now();
  buffer[2] = kDefaultReadingValue;
}

test(() => assert_throws(
    new RangeError(),
    () => new AmbientLightSensor({frequency: -60})),
    'Test that negative frequency causes exception from constructor.');

sensor_test(sensor => {
  sensor.mockSensorProvider.setGetSensorShouldFail(true);
  let ambientLightSensor = new AmbientLightSensor();
  ambientLightSensor.start();
  return new Promise((resolve, reject) => {
    ambientLightSensor.onstatechange = event => {
      if(ambientLightSensor.state == 'errored') {
        resolve();
      }
    };
  });
}, 'Test that sensor state changes to "errored" when sensor is not supported.');

sensor_test(sensor => {
  sensor.mockSensorProvider.setGetSensorShouldFail(true);
  let ambientLightSensor = new AmbientLightSensor();
  ambientLightSensor.start();
  return new Promise((resolve, reject) => {
    ambientLightSensor.onerror = event => {
      assert_equals(ambientLightSensor.state, 'errored');
      console.log(event.error.message);
      assert_equals(event.error.name, 'NotFoundError');
      ambientLightSensor.onerror = null;
      resolve();
    };

  });
}, 'Test that "onerror" is send when sensor is not supported.');


sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 560});
  ambientLightSensor.start();

  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => {
        mockSensor.setStartShouldFail(true);
        return mockSensor.addConfigurationCalled(); })
      .then(mockSensor => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onerror = event => {
            assert_equals(ambientLightSensor.state, 'errored');
            assert_equals(event.error.name, 'OperationError');
            ambientLightSensor.onerror = null;
            resolve();
          };
        });
      });
  return testPromise;
}, 'Test that "onerror" is send when start() call has failed.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 560});
  ambientLightSensor.start();

  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => { return mockSensor.addConfigurationCalled(); })
      .then(mockSensor => {
         return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = event => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }

            if (ambientLightSensor.state === 'active') {
              let configuration = mockSensor.active_sensor_configurations_[0];
              assert_equals(configuration.frequency, 60);
              ambientLightSensor.stop();
            }
          };
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that frequency is capped to 60.0 Hz.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 60});
  ambientLightSensor.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = event => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }

            if (ambientLightSensor.state === 'active') {
              ambientLightSensor.stop();
            }
          };
          ambientLightSensor.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that sensor can be successfully created if sensor is supported.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor();
  ambientLightSensor.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = event => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }

            if (ambientLightSensor.state === 'active') {
              ambientLightSensor.stop();
            }
          };

          ambientLightSensor.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that sensor can be constructed with default configuration.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 60});
  ambientLightSensor.start();

  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => { return mockSensor.addConfigurationCalled(); })
      .then(mockSensor => {
         return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = event => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }

            if (ambientLightSensor.state === 'active') {
              ambientLightSensor.stop();
            }
          };
         });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that addConfiguration and removeConfiguration is called.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 60});
  ambientLightSensor.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => {
        return mockSensor.setUpdateSensorReadingFunction(update_sensor_reading);
      })
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = event => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }
          };

          ambientLightSensor.onchange = () => {
            assert_equals(ambientLightSensor.reading.illuminance, kDefaultReadingValue);
            ambientLightSensor.stop();
          };

          ambientLightSensor.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that onChange is called and sensor reading is valid.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor({frequency: 60});
  ambientLightSensor.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => {
        return mockSensor.setUpdateSensorReadingFunction(update_sensor_reading);
      })
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = () => {
            if (ambientLightSensor.state === 'idle') {
              assert_equals(ambientLightSensor.reading, null);
              resolve(mockSensor);
            }
          }

          ambientLightSensor.onchange = () => {
            assert_equals(ambientLightSensor.reading.illuminance, kDefaultReadingValue);
            ambientLightSensor.stop();
          }
          ambientLightSensor.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that sensor reading is not updated when sensor is stopped.');

sensor_test(sensor => {
  let ambientLightSensor = new AmbientLightSensor();
  ambientLightSensor.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => {
        return mockSensor.setUpdateSensorReadingFunction(update_sensor_reading);
      })
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onchange = () => {
            if (ambientLightSensor.reading.illuminance == kDefaultReadingValue) {
              resolve(mockSensor);
            }
          }
        ambientLightSensor.onerror = reject;
        });
      })
      .then((mockSensor) => {
        testRunner.setPageVisibility("hidden");
        return mockSensor.suspendCalled();
      })
      .then((mockSensor) => {
        testRunner.setPageVisibility("visible");
        return mockSensor.resumeCalled();
      })
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          ambientLightSensor.onstatechange = () => {
            if (ambientLightSensor.state === 'idle') {
              resolve(mockSensor);
            }
          }
          ambientLightSensor.stop();
          ambientLightSensor.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that sensor receives suspend / resume notifications when page'
    +' visibility changes.');


sensor_test(sensor => {
  let sensor1 = new AmbientLightSensor({frequency: 60});
  sensor1.start();

  let sensor2 = new AmbientLightSensor({frequency: 20});
  sensor2.start();
  let testPromise = sensor.mockSensorProvider.getCreatedSensor()
      .then(mockSensor => {
        return mockSensor.setUpdateSensorReadingFunction(update_sensor_reading);
      })
      .then((mockSensor) => {
        return new Promise((resolve, reject) => {
          sensor1.onstatechange = event => {
            if (sensor1.state === 'idle') {
              resolve(mockSensor);
            }
          };

          sensor1.onchange = () => {
            // Reading value is correct.
            assert_equals(sensor1.reading.illuminance, kDefaultReadingValue);

            // Both sensors share the same reading instance.
            let reading = sensor1.reading;
            assert_equals(reading, sensor2.reading);

            // After first sensor stops its reading is null, reading for second
            // sensor sensor remains.
            sensor1.stop();
            assert_equals(sensor1.reading, null);
            assert_equals(sensor2.reading.illuminance, kDefaultReadingValue);

            sensor2.stop();
            assert_equals(sensor2.reading, null);

            // Cached reading remains.
            assert_equals(reading.illuminance, kDefaultReadingValue);
          };

          sensor1.onerror = reject;
          sensor2.onerror = reject;
        });
      })
      .then(mockSensor => { return mockSensor.removeConfigurationCalled(); });

  return testPromise;
}, 'Test that sensor reading is correct.');

</script>
